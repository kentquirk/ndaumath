package main

//go:generate gopherjs build --minify

// This system generates js code from go source
// so that we can have a single-source solution for keys, addresses, and signatures.
// Use "go generate" to build this.

// object API --
//  NewPrivateMaster(seed:string) : key -- creates and returns a new private master key using the given seed.
//  NewKey(string) : key -- creates a key from its text representation (if it was valid)
//  key.Neuter() : key -- returns a public key that cannot be used for signing but may be used to generate child public keys.
//  key.Child(index) : key -- returns a child key at the given index; if the parent was private, so is the child.
//  key.HardenedChild(index) : key -- creates a child public key at the index that cannot be used to generate more children.
//  key.Sign(message) : signature -- signs a message and returns a signature
//  signature.Verify(message, key) : bool
//  NewAddress(string) : address -- creates an address object from the string representing it (if valid)
//  key.Address() : address -- generates an address from a public key

import (
	"github.com/gopherjs/gopherjs/js"
	"github.com/miratronix/jopher"
	"github.com/oneiro-ndev/ndaumath/pkg/address"
	"github.com/oneiro-ndev/ndaumath/pkg/key"
)

// Key is the JS object associated with a Key (either public or private; the key itself knows)
// The representation here is the base58 string for the key.
// All functions return Promises and can fail.
type Key struct {
	*js.Object
	Key           string                          `js:"key"`
	Neuter        func(...interface{}) *js.Object `js:"Neuter"`
	Child         func(...interface{}) *js.Object `js:"Child"`
	HardenedChild func(...interface{}) *js.Object `js:"HardenedChild"`
	Sign          func(...interface{}) *js.Object `js:"Sign"`
	Address       func(...interface{}) *js.Object `js:"Address"`
}

// Address is the JS object associated with an address.
type Address struct {
	*js.Object
	Address string                          `js:"address"`
	Verify  func(...interface{}) *js.Object `js:"Verify"`
}

// Signature is generated by the Sign command
type Signature struct {
	*js.Object
	Signature string                          `js:"signature"`
	Verify    func(...interface{}) *js.Object `js:"Verify"`
}

func main() {
	js.Module.Get("exports").Set("newPrivateMaster", jopher.Promisify(newPrivateMaster))

	// validate accepts an ndau address (like those returned by generate) and returns
	// a promise that is resolved with true, or rejected with false.
	// function validate(addr: string): Promise
	js.Module.Get("exports").Set("validate", jopher.Promisify(validateWrapper))

	// generate creates an address of the appropriate kind (which must be one of
	// 'a', 'n', 'e', or 'x') and uses data (which must be at least 32 bytes long
	// and should be a public ndau key) to generate a new ndau key returns a
	// Promise that resolves with the new key, or rejects with an error.
	// function generate(kind: string, data: string) : Promise
	js.Module.Get("exports").Set("generate", jopher.Promisify(generateWrapper))
}

func (k *Key) build(s string) *js.Object {
	k.Key = s
	k.Neuter = jopher.Promisify(k.neuter)
	k.Child = jopher.Promisify(k.child)
	k.HardenedChild = jopher.Promisify(k.hardenedChild)
	// k.Sign = jopher.Promisify(k.sign)
	// k.Address = jopher.Promisify(k.address)
	return k.Object
}

func newPrivateMaster(seed string) (*js.Object, error) {
	k := Key{Object: js.Global.Get("Object").New()}

	km, err := key.NewMaster([]byte(seed), key.NdauPrivateKeyID)
	if err != nil {
		return nil, err
	}
	return k.build(km.String()), nil
}

func (k *Key) neuter() (*js.Object, error) {
	ekey, err := key.NewKeyFromString(k.Key)
	if err != nil {
		return nil, err
	}
	nk, err := ekey.Neuter()
	if err != nil {
		return nil, err
	}
	r := Key{Object: js.Global.Get("Object").New()}
	return r.build(nk.String()), nil
}

func (k *Key) child(n float64) (*js.Object, error) {
	ekey, err := key.NewKeyFromString(k.Key)
	if err != nil {
		return nil, err
	}
	ndx := uint32(n)
	nk, err := ekey.Child(ndx)
	if err != nil {
		return nil, err
	}
	r := Key{Object: js.Global.Get("Object").New()}
	return r.build(nk.String()), nil
}

func (k *Key) hardenedChild(n float64) (*js.Object, error) {
	ekey, err := key.NewKeyFromString(k.Key)
	if err != nil {
		return nil, err
	}
	ndx := uint32(key.HardenedKeyStart + n)
	nk, err := ekey.Child(ndx)
	if err != nil {
		return nil, err
	}
	r := Key{Object: js.Global.Get("Object").New()}
	return r.build(nk.String()), nil
}

func validateWrapper(addr string) (bool, error) {
	_, err := address.Validate(addr)
	return (err == nil), err
}

func generateWrapper(kind string, data string) (string, error) {
	k, err := address.NewKind(kind)
	if err != nil {
		return "", err
	}
	a, err := address.Generate(k, []byte(data))
	return a.String(), err
}
